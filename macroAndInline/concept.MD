# 21. 매크로 함수, 인라인 함수

- 매크로 함수에 대해 배운다
- 인라인 함수에 대해 배운다

---

## 매크로 함수

매크로 함수 정의 방법

```
C
#define 함수 이름 (인자) 치환할 것

define square(x) x * x
x -> x * x로 치환한다는 의미.
```

'매크로 함수' 라 부르는 이유는 정말 하는 일이 함수와 비슷하기 때문.
하지만 매크로 함수와 진짜 함수는 엄연한 차이가 있다.
매크로 함수는 **컴파일 되기 전** 전처리기에 의해 치환될 뿐이다.\
하지만 함수와 다르게, 전처리기에서 해석을 시키므로 나누기나 혹 곱하기 등 소괄호를 통한 처리를 해줘야하기 때문에 사소한 실수 하나로 꽤 큰 문제가 초래될 수 있다.

```
#define PrintVariableName(var) printf(#var "\n");
전처리기 문에서만 사용되는 것 중 # 이 있는데, 어떠한 인자 앞에 # 을 붙이게 되면 이 인자를 문자열로 바꾼다.
```

### '#' 의 친구격인 '##'

둘 다 모두 **전처리기 문** 에서만 사용할 수 있다.\
즉, #define 에서만 사용할 수 있다.\
'##' 문은 입력된 것을 하나로 '합쳐주는' 역할\

매크로 함수는 여러 편리한 점들이 있지만, 까다로운 상황들도 많다.(괄호 처리 등) 이 경우 디버깅하기가 매우 까다롭기 때문에 오랜 시간을 잡아먹는 경우도 많다. 이러한 문제를 해결하기 위해 C 언어에서는 또 다른 해결책을 제시했다.\
=> **_인라인(inline) 함수_**

## 인라인 함수

<현재 gcc 컴파일러 사용 시, inline 함수 컴파일 도중 오류가 발생했다.>\

```
/usr/bin/ld: /tmp/cc5ljOLK.o: in function `main':
inline.c:(.text+0x19): undefined reference to `square'
collect2: error: ld returned 1 exit status
```

---

해당 오류를 Chat GPT를 통해 컴파일을 해결했다.

### 최적화 옵션 사용으로 오류를 해결했음.

gcc -O2 옵션을 통해 최적화 옵션을 통해 해결했다.\
-O2 옵션 : 최적화 옵션. 컴파일러가 더 효율적으로 코드를 처리하도록 할 수 있다.\
단점 : 최적화 옵션을 높이면 코드가 더 효율적으로 컴파일 될 수 있지만, 런타임 에러가 발생할 수 도 있다. 따라서 최적화 수준을 테스트 해봐야 한다.\
-std=c99 옵션을 주었을 때도 오류가 발생했다.\
-fno-inline 옵션 사용\
Chat GPT가 제안한 사안이지만, 이것을 사용하면 인라인 함수 최적화를 비활성화 시키기 때문에, gcc -O2 최적화 옵션을 통해 해결했다.

---

인라인 함수는 함수와는 전혀 다른 행동을 한다.\
함수의 경우 호출을 하게 되면 프로그램의 흐름이 완전히 다른 곳으로 넘어가게 된다.

```
예를 들어
평범한 함수 하나를 만들고, main 함수에서 평범한 함수를 호출 하게 되면, 프로그램의 흐름이 main 함수를 벗어나 메모리 어딘가에 위치한 평범한 함수에 찾아가서 인자를 전달하고 리턴 값을 받은 후에 main 함수로 돌아온다.
 이렇게 함수를 사용하게 되면 프로그램의 흐름이 기존의 함수 내부에서 벗어나 다른 함수에 들렸다가 오게 되는데 이러한 과정을 줄여서
 '함수를 호출하는 과정' 이라고 말하게 된다.
```

단순한 작업만을 하는 함수의 경우에는 굳이 함수로 따로 만들 필요 없이 차라리 main 함수 내에서 직접 처리하는 것이 더 효율적이다.\
=> 이러한 생각을 살려 만든 것이 inline 함수.\
inline 형식으로 만든 함수는 우리가 생각하는 함수가 전혀 아니다.\
단순히 **함수** 처럼 보이는 것 일 뿐.\
inline 함수를 사용하게 되면 마치 매크로 함수를 사용한 후 치환되는 것과 정확히 동일해진다.\
매크로 함수와 차이점이 있다면, 매크로 함수와는 달리 인라인 함수는 전처리기가 무식하게 치환하는 것이 아니다.\
매크로 함수를 사용했을 땐 전처리기가 무식하게 치환하여 연산자 우선 순위를 정확하게 고려해서 괄호 처리를 했어야 했다.\
**_인라인 함수_** 의 경우 똑똑한 컴파일러가 인라인 함수를 사용한 문장 내부에서 적절하게 **_우리가 보통 함수를 사용하는 것 처럼_** 바꿔 준다.\

```
/* 다른 인라인 함수 예제*/
#include <stdio.h>
__inline int max(int a, int b) {
  if (a > b)
    return a;
  else
    return b;
}
int main(int argc, char **argv) {
  printf("3 과 2 중 최대값은 : %d", max(3, 2));
  return 0;
}
해당 코드를 컴파일러가
int main(int argc, char **argv) {
  printf("%d 과 %d 중 최대값은 : %d \n", 3, 2, 3 > 2 ? 3 : 2);
  return 0;
}
이러한 형태로 작성한 코드와 동일한 값을 출력할 것이다.
```

---

많은 사람들이 매크로 함수보다는 인라인 함수를 사용하도록 권장.\
인라인 함수는 매크로 함수와는 달리 **컴파일러** 가 처리하기 때문에 훨씬 더 똑똑하게 동작한다. 일단 매크로 함수와는 달리 인라인 함수는 인자들의 타입을 확인.\
인라인 함수는 매크로와 달리 단순 치환하는 것이 아닌 진짜 함수처럼 동작하기 때문에 훨씬 구현하기 쉽고 편리.\
뿐만 아니라 디버깅 역시 인라인 함수가 편리하다.

## 단순한 작업들을 보기 편하게 함수로 처리하고 싶을 때, 인라인 함수들을 적극적으로 사용한다.

### 결론 : 함수의 호출 과정을 생각했을 때, 굳이 함수로 만들 필요 없거나, 간단한 것들은 직접 구현을 하거나 매크로 함수나 인라인 함수를 사용한다. (전처리기에서 처리되기 때문) 그리고 매크로 함수보단 인라인 함수를 사용하자.
