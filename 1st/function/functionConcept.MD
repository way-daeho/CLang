# 함수
### 보통 C 언어에서, 좋은 함수의 이름은 그 함수가 무슨 작업을 하는지 명확히 하는 것이다. 수학에서는 f(x), g(x) 로 막 정하지만, C 언어에서는 그 함수가 하는 작업을 설명해주는 이름을 정하는 것이 좋다.

### 함수의 정의(definition)
int print_hello()와 같은 부분을 함수의 '정의' 라고 부른다.
함수의 정의 부분에서 3 가지 사실을 알 수 있다.
1. 함수의 반환 형 정보. (통상적으로 정수를 반환하는 함수들은 모두 int를 사용함.)
2. 함수의 이름 '()' 함수의 이름에 포함되는 것이 아닌, 함수라는 사실을 의미한다.

### 좋은 함수의 이름의 조건은 함수가 무슨 일을 하는지에 대해서 잘 설명하는 것.
다만, 함수의 이름이 너무 길어지면 함수를 사용시 너무 불편하므로 20자가 넘어가게 하지 말자.
함수의 이름 역시 변수의 이름 조건과 동일하다.

### 함수의 몸체(body) ->   printf("Hello!! \n"); return 0;
### 함수의 호출 부분(call) -> 단순히 함수의 이름을 써주시기만 하면 됩니다.

### 함수의 종료 2가지
1. 반환이 되어 종료를 하게 되는 것
2. 함수의 끝 부분까지 실행하여 종료되는 것.
-> 함수는 반환을 하여 종료되는 것이 안전하다.
한 가지 중요한 사실은 return 을 실행하면 함수는 무조건 종료되어 함수를 호출하였던 부분으로 돌아간다.

## 메인(main) 함수
왜 하필 main이란 이름 일까?
프로그램을 실행할 때 컴퓨터가 main 함수부터 찾기 때문.
메인 함수의 return 데이터는 운영체제가 받아드린다.
정상 종료 -> 0
비정상 종료 -> 1

main 함수에서 선언한 변수의 내용은 함에서 정의된 변수와 독립된 객체이다.

## 함수의 인자
함수는 main 함수안의 변수를 사용할 수 없을 뿐더러 main 함수에서도 함수에 변수들이 뭐가 있는지 알 수 없다.
인자(argument, 혹은 매개변수(parameter))를 이용하면 이러한 일을 가능하게 한다.
### 함수의 인자는 '함수를 호출한 것과, 함수를 서로 연결해 주는 통신 수단'이다.
C 에선 '매개 변수' 라고 부른다.
int main() {
  int my_money = 100000;
  printf("2009.12.12 재산 : $%d \n", slave(my_money));

  return 0;
}
일단, slave 함수를 호출하는 호출자(caller) 의 코드를 살펴봅시다. printf 에서, 맨 뒤에 %d 에 들어갈 값으로 slave(my_money) 가 반환 하는 값을 넣었습니다. slave(my_money) 가 반환하는 값을 먼저 넣기 위해선 slave 함수를 호출해야 하는데 이 때 my_money 의 값이 slave 함수의 인자로 전달이 됩니다. 그러면 slave 함수는 아래의 코드를 실행하겠지요.

함수의 인자로 넘어가지만, 그 인자는 함수의 값만 빌려줄 뿐, 메인함수에서 매개변수로 보낸 값의 실제 값을 변경 키지 못한다. 그 이유는 그저 같은 값을 가진 채로 초기화된 메모리상의 또 다른 변수 이기 때문이다.

실제로 값을 변경하기 위서 포인터를 이용한다.
---
## 포인터로 받는 인자
pi 가 i 의 주소값을 가지고 있으므로 pi 를 출력했을 때 그 값은 i 의 주소값과 같을 수 밖에 없습니다. 이는 두 번째 printf 문장에서 확인할 수 있습니다. 또한 그 아래 *pi 를 통해서 i 를 간접적으로 접근할 수 있습니다. 왜냐하면 * 라는 단항 연산자의 의미가 '내가 가지는 주소값에 해당하는 변수를 의미해라' 이기 때문에 *pi 는 pi 가 가리키고 있는 변수인 i 를 의미할 수 있게 됩니다. 즉, pi 를 통해서 굳게 떨어져 있던 main 과 change_val 함수의 세계 사이에 다리가 놓이게 되는 것이지요.

간혹 pi 가 main 함수에서 정의된 것이라고 착각하는 분들이 있는데, pi 역시 change_val 함수 내에서 정의된 변수 입니다.

서로 다른 변수이지만, 주소값을 통해서 값을 변경할 수 있다.

어떤 함수가 특정한 타입의 변수/배열의 값을 바꾸려면 값을 바꾸려면 함수의 인자는 반드시 그 타입을 가리키는 포인터를 이용해야 한다!

## 함수의 원형
우리가 여태까지 사용하였던 함수들은 모두 main 함수 위에서 정의되고 있었습니다. 그러면, 그 정의를 main 함수 아래에서 한다면 어떻게 될까요? 사실, 대부분의 사람들의 경우 main 함수를 제일 위에 놓고 나머지 함수들은 main 함수 뒤에 정의하게 됩니다. 

함수의 원형을 사용하는 것(prototype)
함수의 원형을 사용하면 파라미터를 사용하면 컴파일 시, 컴퓨터가 오류를 내뿜지 않고 어떠한 인자가 필요한지 알 수 있다. (함수를 main 함수 아래에 작성한다면.)

## 배열을 인자로 받기
arr(배열의 이름)은 배열의 시작 주소 값을 갖고 있다.
arr = &arr[0]

## 더블 포인터 인자
*포인터 변수를 가리키는 포인터는? **포인터 *pa = &a **ppa = &pa 일 때, *ppa = pa이다!

## 2차원 배열 인자
함수 인자의 경우에만 이러한 형태의 인자로 표현할 수 있다!
int add1_element(int (*arr)[2], int row) == int add1_element(int arr[][2], int row)

## 상수인 인자
상수로 인자를 받아들이는 경우 대부분은 함수를 호출해도 그 인자의 값이 바뀌지 않는 경우에 자주 사용.

## 함수 포인터
프로그램의 코드 자체가 메모리 상에 존재.
변수를 가리키는 포인터 처럼 함수 포인터는 메모리 상에 올라간 함수의 시작 주소를 가리키는 역할을 하게 된다.

함수 포인터가 함수를 가리키기 위해서는 그 함수의 시작 주소값을 알아야 한다.
배열과 마찬가지로 함수의 이름이 바로 함수의 시작 주소값을 나타낸다.

함수 포인터 정의 방법.
int (*pmax)(int, int);
함수 포인터로 특정한 함수를 가리킬 때, 그 함수는 반드시 pmax 의 정의와 일치해야한다.

함수 포인터의 일반적인 정의
(함수의 리턴형) (*포인터 이름) (첫 번째 인자 타입, 두 번째 인자 타입...)
// 만일 인자가 없다면 그냥 괄호 안을 비워두면 된다.
ex -> int (*a)()
특정한 함수의 시작 주소값을 알려면 그냥 함수 이름을 넣어주면 된다.
pmax = &max -> 틀림.

int increase(int (*arr)[3], int row)
특정한 타입의 인자를 판별하는 일은 단순히 변수의 이름만을 뺴면된다.
첫 번째 인자의 형 int (*)[3] 즉, increase 함수를 가리키는 함수 포인터의 원형은 다음과 같다.
int (*pfunc)(int (*)[3], int);

## 13 - 4 마술 상자 함함수  (생각해볼 문제에 대한 아이디어 꼭 보기!)