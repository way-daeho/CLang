# string(문자열)
## 15 - 1
- 널 종료 문자열 (Null terminated string)
- 문자열 활용
- 문자열 입력

문자열 -> 문자들의 배열, 즉 char 배열에 저장함.

### 널 - 종료 문자열 (Null - terminated string)
컴퓨터에선 문자열을 char 배열에 저장한다.
(실질적으로 메모리에 저장된 값은 각 문자에 해당하는 아스키 값.)
문자열은 문자들이 하나로 뭉쳐서 다니는 것 이기 때문에, 문자열을 이용할 때 마다 문자열의 길이를 알아야 한다면 정말로 불편한 일이 아니다.
-> C 개발자들은 해결책을 내놓음
문자열의 끝에 여기까지 문자열 이였다. 라고 알려주는 종료 문자를 넣었다.
이 종료 문자 -> ASCII 0 '\0' <- 널(NULL) 이라고 부름

널 문자가 들어갈 공간이 있어야 하기 때문에 3글자라고 해도 배열은 4칸이 필요.
널 종료 문자가 편리한 이유 -> 컴퓨터가 문자열의 끝을 쉽게 구할 수 있기 때문.
's 문자열을 출력해' -> 컴퓨터 알아서 널이 나올 때 까지 출력

\0의 아스키값 0

"psi" -> 작은 따옴표로 표시해서 배열에 저장하는 일은 매우 번거로운 일.
문자들을 쭉 나열한 것을 큰 따옴표로 묶어주게 되면 알아서 각각의 문자로 넣어준다.
문자열을 만들 때, 널 문자를 위한 공간 하나를 더 추가해야함.

"" -> 큰 따옴표는 문자열 (한 개 이상의 문자)를 지정할 때 사용된다.
'' -> 작은 따옴표는 한 개의 문자를 지정할 때 사용된다.

#### 포인터 리뷰
char* 을 이용해서 char 배열을 가리킬 수 있다.
str이라는 char 을 가리키는 포인터가 배열 word를 가리키고 있다.

[] 안을 빈칸으로 두었다는 뜻은 컴파일러가 알아서 원소의 수를 세어서 빈칸을 채워 넣으라는 뜻 -> 단순히 빈칸으로 남겨 놓기만 하면된다 (물론 배열의 정확한 크기를 알아야 할 상황이 온다면 특별히 값을 명시해줘야한다.)

### 문자의 개수를 세자
프로그래밍을 하다 보면 특정한 문자열에 들어 있는 문자의 개수를 세는 일이 많을 것.
char 형을 가리키는 포인터 형태, char 배열을 취할 수 있음
일차원 배열을 가리키는 포인터는 (그 배열의 형)*
while (str[i]) -> 0이 될 때 까지 i 증가.
str[i] == 0 NULL 문자일 때.
즉, 문자열의 끝 부분일 때 i 값 증가를 멈춘다.

scanf 를 통해 문자열을 입력 받는다.
입력 받는 형식 -> %s 
두 번째 인자를 words 약간 이상함.
&를 이용해서 주소값을 전달헀는데 여기서 &를 붙이지 않는다.
words 라는 배열의 이름 자체가 배열을 가리키고 있는 포인터 이기 때문에 
words 의 값을 전달함으로써 배열의 (시작) 주소값을 잘 전달할 수 있다.

scanf 함수는 엔터가 나올 때 까지 입력 받는다.
문자열을 적는데 띄어 쓰기 한다면... 모든 입력값이 안나온다.

## 15 - 2
#### 이상한 scanf
컴퓨터는 입력값을 한번에 받고 한번에 처리한다.
abcde 를 입력했을 때, 컴퓨터가 각 문자를 입력받을 때 마다 처리 -> 비효율적
원리는 더 복잡하짐나 여러번 반복하는 것 보다 좋은 방법이다.
컴퓨터는 버퍼(buffer)에 저장해둠.
수많은 버퍼 중에서도 키보드의 입력을 처리하는 버퍼 -> 입력버퍼 stdin(입력 스트림)

우리가 키보드 치느 모든 정보는 일시적으로 stdin 에 저장되었다, 나중에 입력이 종료되면 한꺼번에 처리
컴퓨터가 어떻게 우리가 입력을 종료했는지 알 수 있을 까? -> 엔터를 입력
컴퓨터는 개행문자, 즉 \n(키보드 상의 엔터)을 입력을 종료했으니, 버퍼에 들어있는 버퍼에 들어 있는 내용을 갖고 놀아라 라는 뜻으로 받아드림.
그런데 컴퓨터는 \n 까지 버퍼에 저장하게 된다.

참고로 %d 계열의 것들, 즉 수를 입력받는 형식은 수가 아닌 데이터가 와도 입력을 종료.
수 데이터를 입력받는 형식의 경우 처음부터 공백 문자가 나타나면 수가 나타날 때 까지 입력을 계속 받게 된다.(다시 말해, 수를 입력 받는데 엔터를 아무리 쳐도 숫자를 치기 전까지 넘어가지 않는다.)
scanf(' ', '\n', '\t')를 만나기 전까지 	stdin에서 데이터를 가져간 후 버퍼에서 삭제

%c 는 stdin 에서 딱 한개의 문자만을 갖고온다.
만약 stdin 에 아무것도 없다면 사용자의 입력을 기다리고 있겠지만, stdin에 무언가가 있다면 그것을 냉큼 갖고오게 된다.
공교롭게 위에 \n 을 버퍼에 남겨 놓았기 때문에 scanf는 냉큼 c에 저장하게 된다.
즉, c에는 사용자의 입력을 받지도 않고 \n 을 집어 넣은 것.

#### %s 로 scanf 에서 받을 경우
%c 와는 달리 %s 의 경우 컴퓨터가 사용자로 부터 입력을 잘받는다.
scanf("%s", str);
를 실행하게 되면 역시 수 데이터를 입력 받는 형식 처럼실질 적인 데이터 (공백 문자가 아닌 것들) 이 나오기 전 까지 버퍼에 남아 있던 공백 문자들은 무시하고 실질 적인 문자(공백 문자가 아닌 것들)가 입력이 된다면 그 다음 부터 등장하게 되는 공백 문자에서는 종료하게 됩니다. 즉, 기존에 1 을 입력하였을 때 남아있었던 \n 은 사라지고, 내가 aasdfdasfads 를 입력하고 난 후, 엔터를 쳤을 때 들어가는 \n 을 인식 하게 된다는 것이지요.
결론적으로 요약하자면 %s 나 %d 그리고 다른 모든 수 데이터를 입력 받는 형식은 버퍼에 남아 있는 공백 문자에 신경쓰지 않고 사용할 수 있습니다.

-> 그렇다고해서 %s 를 입력 받은 후 버퍼가 완벽히 깨끗해지는 것은 아님.개행 문자는 뒤에 남아있음.

### 도대체 이 문제를 어떻게 해결하냐
이를 해결할 수 있는 방법이 여러가지
버퍼 비우기
getchar() 함수의 역할 : stdin 에서 한 문자를 읽어와서 그 값을 리턴한다.
한 문자를 읽어오면 읽어온 문자는 stdin에서 사라짐. 따라서 \n을 stdin에서 읽어와 지워버릴 수 있다.
scanf에서 %c 형식 사용 권하지 않음. 정 사용해야한다면.
getchar() 을 scanf 이전에 호출해서 버퍼를 비워줘라.

되도록이면 %c를 사용하지 말자!
문자 하나만을 입력받는 프로그램을 만드려면 %s 형태로 문자열을 입력 받은 뒤, 맨 앞의 한 문자만 취하는 식으로 만들면 된다.

## 결론 : 문자 대신 문자열을 입력 받도록 하자!

# 15 - 3
- 문자열 리터럴(literal) 에 대한 이해
- 문자열 다루기 (복사, 합치기, 비교하기)
## 리터럴(literal)
프로그래밍 언어에서 리터럴이란, 소스 코드 상에서 고정된 값은 갖는 것을 일컫는다.
특히, C언어의 경우 큰 따옴표(")로 묶인 것들을 문자열 리터럴(string literal)이라 부른다.
컴퓨터는 이러한 리터럴들을 따로 모아서 보관. 즉, 프로그램을 실행하면 메모리 상의 특별한 곳에 리터럴들이 보관되어 있는 공간이 생긴다.

프로그램이 실행되서 메모리에 로드되면
1. text segement
2. data segement
3. bss segement
4. heap
5. stack
5 가지 종류의 영역이 존재한다.
텍스트 세그먼트에 프로그램 코드와 상수, 리터럴 등이 여기서 정의.
텍스트 세그먼트에 있는 내용들은 읽기만 가능하다. -> 사용하는 운영체제 환경에 따라 다를 수 있다.

리터럴은 소스 코드 상에서 고정된 값을 갖고 있는 것. 다시 말해 실제 프로그램 실행 중에서도 리터럴의 값은 절대로 변경되서는 안된다.

리터럴이 보관되는 곳은 오직 읽기만 가능한 곳
문자열들이 "문자열 리터럴" 이란 이름 하에 메모리 상의 특별한 공간에서 보호 받고 있다.
printf("pstr : %s \n", pstr);
같이 오직 읽기 작업만을 수행하는 printf 의 경우 잘 실행된다.
리터럴 세상세 저장된 리터럴들에 쓰기는 불가능 하지만 적어도 읽기는 허용.
char str[] = "hello"; 에서 "hello" 는 리털이라고 부르기 애매하다. 왜냐하면 위 배열의 정의는 사실 컴파일러에서 아래와 같이 해석된다.
char str[] = {'h', 'e', 'l', 'l', 'o', '\0'};
그냥 str이라는 배열에 hello 라는 문자열을 복사하게 될 뿐.
위 배열은 텍스트 세그먼트가 아니라 스택이라는 메모리 수정이 가능한 영역에 정의.

VS2017 이상, 리터럴을 char*	가 가리킬 수 없다. 반드시 const char *가 가리켜야한다.
덕분에 리터럴을 수정하는 괴랄한 짓을 컴파일 단에서 막을 수 있다.

### 문자열 다시 갖고 놀기
문자열을 자유롭게 다루려면 다음과 같은 함수들이 필요하다
- 문자열 내의 총 문자의 수를 세는 함수
- 문자열을 복사하는 함수
- 문자열을 합치는 함수 (더하는)
- 문자열을 비교하는 함수

#### 문자열을 복사하는 함수
어떻게 하면 만들 수 있을까?
함수를 만들기 전에 반드시 고려해야 하는 사항들은 다음과 같다.
1. 이 함수는 무슨 작업을 하는가? (자세할 수록 좋다)
2. 함수의 리턴형이 무엇이면 좋을까?
3. 함수의 인자로 무엇을 받아야 할까?

특히 1 번의 경우 상당히 중요하다.
"무슨 무슨 함수를 만들어야겠다" 라고 정하지도 않고 무턱대로 함수를 만들다 보면 소스 코드가 상당히 난잡해지고 이해하기 힘들게 된다.

우리는 말 그래도 문자열을 복사하는 함수, 즉 a 라는 문자열이 있다면 문자열의 모든 내용을 b 로 복사하는 함수.

두 번째로 리턴형을 생각. 문자열을 복사하는 함수에서 무슨 리턴형이 필요하냐고 물을 수도 있는데, 복사가 성공적으로 되었다면 1을 리턴하도록 만들것.
-> int 형

세 번째로 함수의 인자로 무엇을 받아야 할 지.
당연하게도 두 개의 문자열을 받아야 하므로 포인터를 사용하낟.
char 형 배열이기에 char* 을 인자 2개 갖는 함수를 만들 것.